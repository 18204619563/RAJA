//AUTOGENERATED BY gen_forallN_generic.py

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
// Copyright (c) 2016, Lawrence Livermore National Security, LLC.
// 
// Produced at the Lawrence Livermore National Laboratory
// 
// LLNL-CODE-689114
// 
// All rights reserved.
// 
// This file is part of RAJA. 
// 
// For additional details, please also read raja/README-license.txt.
// 
// Redistribution and use in source and binary forms, with or without 
// modification, are permitted provided that the following conditions are met:
// 
// * Redistributions of source code must retain the above copyright notice, 
//   this list of conditions and the disclaimer below.
// 
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the disclaimer (as noted below) in the
//   documentation and/or other materials provided with the distribution.
// 
// * Neither the name of the LLNS/LLNL nor the names of its contributors may
//   be used to endorse or promote products derived from this software without
//   specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL LAWRENCE LIVERMORE NATIONAL SECURITY,
// LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
// DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
// IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
// POSSIBILITY OF SUCH DAMAGE.
// 
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//

  
#ifndef RAJA_forallN_generic_HXX__
#define RAJA_forallN_generic_HXX__

#include "RAJA/LegacyCompatibility.hxx"
#include "RAJA/forallN_generic_lf.hxx"

namespace RAJA {


template<typename POLICY, typename ...Indices, typename...ExecPolicies, typename BODY, typename... Ts>
RAJA_INLINE
void forallN_impl_extract(RAJA::ExecList<ExecPolicies...>, BODY const &body, const Ts ... args){
  static_assert(sizeof...(ExecPolicies) == sizeof...(args),
                "The number of execution policies and arguments does not match");
  // extract next policy
  typedef typename POLICY::NextPolicy             NextPolicy;
  typedef typename POLICY::NextPolicy::PolicyTag  NextPolicyTag;

  // Create index type conversion layer
  typedef ForallN_IndexTypeConverter<BODY, Indices...> IDX_CONV;

  // call policy layer with next policy
  forallN_policy<NextPolicy, IDX_CONV>(NextPolicyTag(), IDX_CONV(body), ForallN_PolicyPair<ExecPolicies, Ts>(args)...);
}

template<typename T, typename T2>
T return_first(T a, T2 b) { return a; }

template<typename POLICY, typename...Indices, size_t ... Range, typename BODY, typename... Ts>
RAJA_INLINE
void forallN_impl(VarOps::index_sequence<Range...>, BODY const &body, const Ts ... args){
  
  static_assert(sizeof...(Indices) <= sizeof...(args),
                "More index types have been specified than arguments, one of these is wrong");
  // Make it look like variadics can have defaults
  using index_type_tuple = decltype(
                             std::tuple_cat(
                               std::tuple<Indices...>(),
                               std::tuple<decltype(return_first((Index_type)0, args))...>()));
  forallN_impl_extract<POLICY, typename std::tuple_element<Range, index_type_tuple>::type...>(typename POLICY::ExecPolicies(), body, args...);
}

template<typename POLICY, typename...Indices, size_t...I0s, size_t...I1s, typename...Ts>
RAJA_INLINE
void fun_unpacker(VarOps::index_sequence<I0s...>,
                  VarOps::index_sequence<I1s...>,
                  std::tuple<Ts...> args)
{
    forallN_impl<POLICY, Indices...> (VarOps::make_index_sequence<std::tuple_size<decltype(args)>::value - 1>(),
                                      std::get<I0s>(std::move(args))..., std::get<I1s>(std::move(args))...);
}

template<typename POLICY, typename...Indices, typename... Ts>
RAJA_INLINE
void forallN(Ts... args)
{
    fun_unpacker<POLICY, Indices...> (
            VarOps::index_sequence<sizeof...(args) - 1>{},
            VarOps::make_index_sequence<sizeof...(args) - 1>{},
            std::make_tuple(std::forward<Ts>(args)...));
}

} // namespace RAJA
  
#endif

